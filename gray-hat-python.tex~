\documentclass[12pt, a4paper, oneside]{book}
\usepackage[english,russian]{babel}
\usepackage{hyperref}
\usepackage[tikz]{bclogo}

\begin{document}

\begin{titlepage}
\begin{center}
% Title
\HRule \\[0.4cm]
{ \huge \bfseries Gray Hat Python}\\[0.4cm]
\HRule \\[1.5cm]
\textsc{\Large Автор: Justin Seitz}\\[0.5cm]
% Author and supervisor
\begin{minipage}{0.4\textwidth}
\begin{flushleft} \large
\emph{Перевод: }\\
\href{http://reverse4you.org}{reverse4you.org}, \href{http://chumichev.blogspot.com/}{M.Chumichev}
\end{flushleft}
\end{minipage}
\begin{minipage}{0.4\textwidth}
\begin{flushright} \large
\emph{Редактор:} \\
\href{http://vk.com/woodooshaman}{ks\_ks}
\end{flushright}
\end{minipage}
\vfill
% Bottom of the page
\end{center}
\end{titlepage}


\section*{Введение}\\

Я изучил Python конкретно для хакинга - и я осмелюсь сказать, что это утверждение правдиво для многих других так же. Я провел достаточно много времени в изучении языка, который хорошо приспособлен для хакинга и реверс инженерии, и несколько лет назад стало весьма очевидно, что Python становится настоящим лидером среди языков ориентированных на хакинг. Однако хитрость была в том, что не было стоящего руководства по теме, как использовать Python для различных задач хакинга. Вам приходится копаться в форумах и мануалах, и обычно проводить достаточно много времени времени пошагово просматривать код, чтобы заставить его работать правильно. Эта книга нацелена на заполнение этого разрыва путем предоставления вам беглого курса как использовать Python для хакинга и реверс-инженерии различными способами.\\

Книга составлена так, что позволит вам изучить некоторые теоретические основы большинства средств и техник хакинга, включающих дебаггеры, бэкдоры, фаззеры, эмуляторы, и инъекции кода, обеспечивая вам некоторое представление о том, как готовые инструменты Python могут быть использованы, когда не требуются обычные решения. Вы изучите не только как использовать инструменты, основанные на Python, но и как создавать инструменты на языке Python. Но предупреждаем, это не исчерпывающее руководство! Существует много-много инструментов для ИБ (информационной безопасности), написанных на Python, которые я не рассматривал. Однако, эта книга позволит вам освоить много подобных навыков по применению приложений, которые вы сможете использовать, отлаживать, расширять, и настраивать любое Python-приложение по вашему выбору.\\

Есть несколько способов изучения этой книги. Если вы новичок в Python или в разработке инструментов для хакинга, то вам стоит читать книгу от начала до конца по порядку. Вы изучите немного необходимой теории, запрограммируете кучу кода на Python, и получите твёрдые знания о том, как решить множество задач хакинга и реверсинга по прочтению книги. Если вы уже знакомы с Python и хорошо понимаете библиотеку ctypes Python, то переходите сразу к Главе 2. Для тех из вас, кто "в теме", вполне достаточно переходить к нужным разделам книги и использовать фрагменты кода или определенные разделы, как вам надо в ваших повседневных задачах.\\
\newpage

Я потратил много времени на отладчики, начиная с теории отладки в Главе 2, и продолжая прямо до Immunity Debugger (модификация OllyDbg прим.) в Главе 5. Отладчики это важные инструменты для любого хакера, и я не стесняюсь рассказывать вам о них достаточно подробно. Двигаясь дальше, вы узнаете некоторые техники перехвата (hooking) и инъекций в Главах 6 и 7, которые вы можете добавить в некоторые концепции отладки управления программой и манипулирования памятью.\\

Следующий раздел книги нацелен на взлом приложений используя фаззеры (fuzzers). В Главе 8 вы начнете изучать фаззинг (fuzzing), и создадите свой простейший файловый фаззер. В Главе 9 мы будем использовать мощный Sulley fuzzing framework чтобы сломать настоящий FTP-демон, и в Главе 10 вы узнаете как создать фаззер для взлома драйверов Windows.\\

В Главе 11, вы увидите, как автоматизировать статические задачи аналитики в IDA Pro, популярного средства для бинарного статического анализа. Мы завершим книгу темой PyEmu, основанного на Python эмулятора компьютера, в Главе 12.\\

Я постарался представить исходные коды несколько меньше, с детальными пояснениями о том, как работает код, вставленный в определенных точках. Часть времени при изучении нового языка, или изготовлении новых библиотек, проводится в необходимом усердном переписывании кода и отладки совершенных вами ошибок. Я поощряю ваш ручной ввод кода. Все исходные коды к вашему удовольствию представлены на официальном сайте книги.\\

Ну а теперь приступим к программированию!
\newpage

\tableofcontents

\chapter{Настройка рабочего окружения}
\addcontentsline{toc}{section}{Intro}
\section*{Intro}

Прежде чем вы начнете совершенствоваться в искусстве программирования в Серой Шляпе на языке Python, вам следует пройти самую неинтересную часть этой книги - настройки вашей будущей рабочей среды разработки. Весьма важно, чтобы вы имели хорошую и удобную среду разработки, которая позволит вам провести время в поглощении крайне интересной информации в данной книге, а не спотыкаться и набивать шишки, пытаясь заставить ваш код выполняться.\\

Эта глава быстро покрывает тему установки и настройки Python 2.5 (на момент перевода версия Python уже 2.6, как будет работать с 3 версией без понятия, но всё равно для всех примеров в книге будет использоваться Python именно версии 2.5. прим. пер.), конфигурирования вашего рабочего окружения Eclipse, и основы написания Си-совместимого кода на Python. Как только вы настроите окружение и поймете основы, мир будет для вас устрицей, а эта книга покажет вам, как её открыть.

\section{Требования к системе}

Я предполагаю, что вы используете 32-битную ОС, основанную на базе Windows (XP, Vista, 7). Windows имеет широкий спектр инструментов и хорошо поддается для программирования на Python. Все главы этой книги ориентированны в первую очередь на Windows, и большинство примеров будут работать только с ОС Windows.\\

Однако, будет несколько примеров, которые вы можете запустить на дистрибутиве Linux. Для разработки под Linux я рекомендую вам скачать 32-битный дистрибутив Linux'a как VMware устройства. Проигрыватель VMware устройств бесплатен, и позволяет вам быстро перемещать файлы с вашей рабочей системы на виртуальную Linux машину. Если у вас завалялся лишний компьютер, можете попробовать свои силы и установить полноценную Linux систему. Для целей книги использовался основанный на Red Hat Linux дистрибутив, вроде Fedora Core 7 или Centos 5. Конечно, в качестве альтернативы, вы можете запустить Linux и сэмулировать на нём Windows. Это дело вашего вкуса.\\

\begin{bclogo}{Бесплатные образы для VMware}

На сайте VMware есть каталог бесплатных устройств. Эти устройства позволяют обратному разработчику (реверс инженеру) или исследователю уязвимостей разместить вредоносную программу (malware) или приложения на виртуальной машине, сокращая к минимуму риски для физической инфраструктуры и предоставляют изолированный "черновик" для работы. Вы можете посетить страницу виртуальных устройств по адресу и скачать плеер по адресу.
\end{bclogo}

\section{Получение и установка Python 2.5}

Среда Python устанавливается быстро и безболезненно как на Linux так и на Windows. Пользователям Windows облегчит жизнь установщик, который позаботится обо всех настройках, однако на Linux вы будете собирать и устанавливать Python из исходных кодов (Однако на очень многих дистрибутивах Linux Python 2.5 установлен "из коробки").

\subsection{Установка Python в Windows}

Пользователи Windows могут получить установщик с официального сайта Python. Только дважды щелкните мышкой по файлу установщика и следуйте далее шаг за шагом по этапам установки. Установщик создаст каталог 'C:\Python25\'. В этом каталоге будут установлены файл python.exe - интерпретатор команд Python, а так же все стандартные библиотеки.
Примечание: Вместо этого вы можете установить отладчик Immunity Debugger, который содержит не только сам отладчик, но и установщик Python 2.5. В последних главах книги вы будете использовать Immunity Debugger для многих задач, поэтому вы можете "убить двух зайцев" одной установкой. Чтобы скачать и установить Immunity Debugger, посетите http://debugger.immunityinc.com
\subsection{Установка Python в Linux}

Для установки Python 2.5 в ОС Linux, вам следует скачать и скомпилировать исходные коды. Это дает вам полный контроль над настройками в процессе установки Python в ОС на базе Red Hat. Процесс установки подразумевает, что вы будете выполнять все следующие команды от имени пользователя root(суперпользователя).

Первым шагом будет загрузка и распаковка исходного кода Python 2.5. В командном терминале (консоли) вводите следующее:
Код:
\begin{verbatim}
# cd /usr/local
# wget http://python.org/ftp/pyton/2.5.1/Python-2.5.1.tgz
# tar -zxvf Python-2.5.1.tgz
# mv Python-2.5.1 Python25
# cd Python25
\end{verbatim}
Вы только что скачали и распаковали исходный код в '/usr/local/Python25'. Следующим шагом будет компиляция исходного кода и проверки работоспособности интерпретатора Python:
Код:
\begin{verbatim}
# ./configure --prefix=/usr/local/Python25
# make && make install
# pwd
/usr/local/Python25
#python
Python 2.5.1 (r251:54863, Mar 14 2012, 07:39:18)
[GCC 3.4.6 20060404 (Red Hat 3.4.6-8)] on Linux2
Type "help", "copyright", "credits" or "license" for more information.
>>>
\end{verbatim}
Теперь вы находитесь в интерактивной оболочке Python, которая предоставляет вам полный доступ к интерпретатору Python и любой встроенной библиотеке. Быстрая проверка покажет, что команды интерпретируются верно:
Код:
\begin{verbatim}
>>> print "Hello World!"
Hello World!
>>> exit()
#
\end{verbatim}
Отлично! Все работает, как вам надо. Чтобы застраховаться, что ваше пользовательское окружение находит, где находится интерпретатор Pyton, автоматически, вам следует изменить файл '/root/.bashrc'. Лично я использую текстовый редактор nano для всех моих работ с текстом, но вы вольны выбрать любой текстовый редактор, с которым вам комфортно работать. Откройте файл '/root/.bashrc' и в конце файла добавьте следующую строку:
Код:
\begin{verbatim}
export PATH=/urs/local/Pyton25/:$PATH
\end{verbatim}
Эта строка укажет окружению Linux что пользователь root может иметь доступ к интерпретатору Python без указания полного пути к нему. Если вы закончите сессию root и затем войдете под root снова, когда вы введете python в любом месте в командной строке, вы незамедлительно окажетесь в интерпретаторе Python.
Примечание переводчика: В Windows можно сделать то же самое. Для этого нужно щелкнуть правой кнопкой мыши на "Мой компьютер" -> "Свойства" -> "Дополнительно" -> "Переменные среды" -> Выбрать переменную "Path" -> "Изменить" -> В строке "Значение переменной" в конце дописать ;C:\Python25. Далее проверяем в командной строке. Вводим python и смотрим, запустился ли интерпретатор, как в случае с Linux или нет.
И так, теперь у вас полностью рабочие интерпретаторы Python как в Windows так и в Linux. Настало время настроить вашу интегрированную среду разработки (IDE). Если у вас есть IDE в которой вам комфортно работать, то можете пропустить следующий раздел.


\section{Настройка среды Eclipse и PyDev}

Как правило для быстрой разработки и отладки Python приложений, абсолютно необходимо использовать полноценную IDE. Взаимодействие популярной среды разработки Eclipse и модуля PyDev к нему дает вам в руки огромное число мощных возможностей, которые не предлагают большинство других средств разработки. Кроме того, Eclipse запускается одинаково в Windows, Linux, и Mac, а так же имеет отличную группу поддержки и разработки. Давайте быстро пройдем все этапы как установить и настроить Eclipse и PyDev:
Скачиваете архив Eclipse Classic для вашей платформы с сайта.
Распаковываете его в "C:\Eclipse".
Запускаете C:\Eclipse\eclipse.exe.
При первом запуске Eclipse спросит вас где хранить ваше рабочее место, вы можете принять предлагаемое место по умолчанию, и поставить галочку в графу "Use this as default and do not ask again". Щелкните на OK.
Как только Eclipse запустится выберите "Help => Install new Software..."
Переходите к полю Work with:.
Кликните на кнопку Add...
В поле Name введите описывающую строку, вроде PyDev Update. Убедитесь, что поле URL содержит http://pydev.org/updates и щёлкните OK. Затем щелкните Finish, и вас выбросит в установщик обновлений Eclipse.
Диалог обновлений появится через несколько мгновений. Когда он появится, выберите PyDev и нажмите Next для продолжения.
Затем прочитайте и примите лицензионное соглашение для PyDev. Если вы согласны с ним, то выберите "I accept the terms in the license agreement".
Щелкните Next и наконец Finish. Вы увидите, как Eclipse установит PyDev дополнение.
В конце кликните Yes в диалоговом меню, которое появится после установки PyDev. Это перезагрузит Eclipse, и запустит его с вашим новеньким PyDev.

На следующей стадии конфигурирования Eclipse вы убедитесь, что PyDev может найти правильный интерпретатор Python для последующего использования, когда вы будете запускать скрипты в PyDev:
Когда запустится Eclipse, выберите "Window => Preferences";
Разверните ветвь PyDev, и выберите Interpreter - Python;
Нажмите кнопку New...;
Укажите путь в Browse: "C:\Python25\python.exe" и кликните Open;
Следующее диалоговое окно покажет вам список включенных библиотек для интерпретатора. Оставьте все как есть и кликните OK;
Затем кликните OK еще раз, чтобы закончить настройку интерпретатора.

Теперь у вас есть установленный и работоспособный PyDev, настроенный для использования свежеустановленного интерпретатора Python 2.5. Прежде чем начнете программировать, вам следует создать новый PyDev проект. Этот проект будет содержать все исходные файлы, данные далее в этой книге. Чтобы настроить новый проект, следуйте следующим образом:
Выберите "File => New => Project";
Разверните ветку PyDev, и выберите PyDev Project. Кликните Next для продолжения;
Назовите "Gray Hat Python". Щёлкните Finish.

Вы заметите, что экран Eclipse перегруппирует себя, и вы увидите проект Gray Hat Python проект в наверху слева. Теперь щелкните правой кнопкой мыши папу src и выберите "New => PyDev Module". В графе Name введите chapter1-test, и кликните на Finish. Вы увидите, что панель вашего проекта обновится, и в этот список будет добавлен файл chapter1-test.py.

Чтобы запустить скрипт Python в среде Eclipse, только кликните кнопку Run As (зеленый кружок с белой стрелкой внутри) на панели инструментов. Чтобы заново запустить последний запущенный скрипт нажмите Ctrl+F11. Когда вы запустите скрипт в Eclipse, вместо командной строки Windows, вы увидите панель внизу среды Eclipse, обозначенной, как Console. Весь вывод ваших скриптов будет отображаться на панели Console. Вы так же можете обратить внимание, что текстовый редактор уже открыл chapter1-test.py и уже ожидает немного сладкого нектара Python.

\subsection{Лучшие друзья Хакера: ctypes}

Модуль ctypes для Python является безусловно одной из самых мощных библиотек, доступных разработчику на Python. Библиотека ctypes позволяет вам вызывать функции в динамически подключаемых библиотеках (dll) и имеет богатые возможности для создания комплексных типов данных языка Си и полезных функций для низкоуровневой работы с памятью. Это необходимо для того, чтобы вы понимали основы того, как использовать библиотеку ctypes, так как вы будете полагаться на эту библиотеку в значительной степени на протяжении всей книги.

\subsection{Использование динамических библиотек}

Первый шаг на пути использования ctypes это понимание, как запускать и получать доступ к функциям в динамически подключаемых библиотеках. Динамически подключаемая библиотека (dynamically linked library) - это скомпилированный бинарный файл, который подключаются к основному процессу во время его выполнения по мере надобности. На платформе Windows эти бинарные файлы называются динамически подключаемые библиотеки, а на платформе Linux - разделяемые объекты (eng. shared objects(SO)). В обоих случаях эти бинарные файлы предоставляют функции через экспортированные имена, какие получают возможность запуска по реальным адресам в памяти. Обычно во время выполнения вам приходится решать, какой будет порядок адресов функций для вызова этих функций, однако с ctypes вся эта грязная работа уже сделана.

Есть три различных способа загрузки dll в ctypes: cdll(), windll(), и oledll(). Разница между ними в том, каким образом вызываются функции этих библиотек, и какие они возвращают значения. Метод cdll() используется для запуска библиотек, которые экспортируют функции, используя стандартное соглашение вызова cdecl. Метод windll() загружает библиотеки, которые экспортируют функции, используя соглашение вызова stdcall, которое является родным соглашением в Microsoft Win32 API. Ну а метод oledll() работает так же, как windll(), однако, он предполагает, что экспортированная функция возвращает Windows код ошибки HRESULT, который используется специально для сообщений об ошибках, возвращаемых функциями Объектной Модели Компонентов (MS Component Object Model, COM).

В качестве небольшого примера, вы возьмете функцию printf() из библиотеки времени исполнения языка C (С runtime) в Windows и Linux, и используете её для вывода в тестовом сообщении. В Windows C runtime находится в msvcrt.dll, находящемся в папке 'C:\WINDOWS\System32\', а в Linux это libc.so.6, которая по умолчанию находится в '/lib/'. Создайте следующий скрипт Python или в Eclipse, или в вашей обычной рабочей директории Python, и введите следующий код:\\
Код:
\begin{verbatim}
# chapter1-printf.py: Код для Windows
from ctypes import *

msvcrt = cdll.msvcrt
message_string = "Hello world!\n"
msvcrt.printf("Testing: %s", message_string)
\end{verbatim}
Этот скрипт выводит следующее:\\
Код:
\begin{verbatim}
C:\Python25\python chapter1-printf.py
Testing: Hello world!
C:\Python25>
\end{verbatim}
Под Linux этот пример будет немного отличаться, но делать будет то же самое. Перейдите в Linux и создайте chapter1-printf.py в вашей директории '/root/'

\begin{bclogo}{Понимание соглашений вызовов}

Соглашение вызовов описывает как правильно вызывать определенную функцию. Оно включает в себя порядок того, как выделяются параметры функции, какие параметры функции помещаются в стек или переходят в регистры, и как раскручивается стек при возвращении функцией значения. Вам надо научиться понимать два соглашения вызовов: cdecl и stdcall. В соглашении cdecl параметры помещаются в стек справа налево, и вызывающий функцию ответственен за очистку стека от аргументов. Это соглашение используется в большинстве C-систем на архитектуре x86.\\

Вот пример вызова функции с помощью cdecl:\\

На языке C:\\
Код:
\begin{verbatim}
int python_rocks(reason_one, reason_two, reason_tree);
\end{verbatim}
На ассемблере x86:\\
Код:
\begin{verbatim}
    push reason_tree
    push reason_two
    push reason_one
    call python_rocks
    add esp, 12
\end{verbatim}
Вы можете ясно увидеть, как передаются аргументы функции. Последняя линия выделяет (увеличивает) стеку 12 байт (у функции 3 параметра, и каждый параметр стека занимает 4 байта, поэтому в сумме дает 12 бит), которых как раз хватает для этих параметров.

Пример соглашения stdcall, которые используются в Win32 API демонстрируется тут:

На языке C:\\
Код:
\begin{verbatim}
int my_socks(color_one, color_two, color_tree);
На языке ассемблера x86:
Код:
    push color_tree
    push color_two
    push color_one
    call my_socks
\end{verbatim}
В данном случае вы видите, что порядок параметров такой же, но очистка стека не проводится вызывающим функцию, а функцией перед возвращением ей полученных значений.

Для обоих соглашений важно запомнить, что возвращенные значения функции хранятся в регистре EAX.
\end{bclogo}
Код:
\begin{verbatim}
# chapter1-printf.py: пример для Linux
from ctypes import *

libc = CDLL("libc.so.6")
message_string = "Hello world!\n"
libc.printf("Testing: %s", message_string)
\end{verbatim}
Данный скрипт в Linux будет выводить следующее:\\
Код:
\begin{verbatim}
# python /root/chapter1-printf.py
Testing: Hello world!
#
\end{verbatim}
Это легко уметь вызывать функции в динамической библиотеке и использовать функции, которые она экспортирует. Вы будете использовать эту технику много раз на протяжении всей книги, поэтому очень важно, чтобы поняли, как это работает.

\subsection{Конструирование типов данных C}

Создание типа данных языка C в Python - это словно откровенная сексуальность в этом гиковском, странном способе (Дословно: Creating a C datatype in Python is just downright sexy, in that nerdy, weird way. кто предложит перевод лучше, будет молодцом ). Наличие этих особенностей позволяет вам полностью использовать компоненты, написанные на C и C++, которые значительно увеличивают мощь языка Python. Кратко просмотрите таблицу 1-1, для понимания того, как взаимосвязаны типы данных C и Python и результирующий тип ctypes.

[рис.1] % TODO: надо подумать как его вставлять, ага

Видите, как хорошо типы данных конвертируются туда и обратно? Используйте эту таблицу для удобства, в случае, если вы забудете преобразование типов. Типы из ctypes могут быть инициализированы со значением, но оно должно быть надлежащего типа и размера. Для демонстрации, откройте вашу оболочку Python и введите несколько следующих примеров:\\
код:
\begin{verbatim}
C:\Python25>python.exe
Python 2.5 (r25:51908, Sep 19 2006, 09:52:17) [MSC v.1310 32 bit (Intel)] on win32
Type "help", "copyright", "credits" or "license" for more information.
>>> from ctypes import *
>>> c_int()
c_long(0)
>>> c_char_p("Hello, world!")
c_char_p('Hello, world!')
>>> c_ushort(-5)
c_ushort(65531)
>>>
>>> seitz = c_char_p("loves the python")
>>> print seitz
c_char_p('loves the python')
>>> print seitz.value
loves the python
>>> exit()
\end{verbatim}

Последний пример описывает вам как переменной seitz присваивается указатель на строку "loves the python". Для доступа к содержимому указателя используется метод seitz.value, который называется разыменовыванием указателя.

\subsection{Передача параметров по ссылке}

Очень часто в C и C++ есть функции, которые ожидают указатель, как один из параметров. Причина в том, что функция может как записывать в этот участок памяти, или, если при передаче по значению параметр слишком велик. В любом случае, ctypes обладает функционалом чтобы сделать именно это, используя функцию byref(). Когда функция ожидает указатель, в качестве параметра, вы вызываете её так: fuction_main( byref (parametr) ).

\subsection{Определение структур и объединений}

Структуры и объединения - важные типы данных, которые часто используются как Win32 API, так и с libc в Linux. Структура - это простая группа переменных, которые могут быть одного или разных типов данных. Вы можете получить доступ к любой содержащейся в структуре переменной, используя точечную нотацию (dot notation), например такую: beer_recipe.amt_barley. Это даст доступ к переменной amt_barley, находящейся в структуре beer_recipe. Следующий пример определит структуру (или struct как их обычно называют для упрощения) как в C так и в Python.
Код на C:\\
Код:
\begin{verbatim}
structure beer_recipe
{
    int amt_barley;
    int amt_water;
};
\end{verbatim}
Код на Python:\\
Код:
\begin{verbatim}
class beer_recipe(Structure):
    _fields_ = [
    ("amt_barley",c_int),
    ("amt_water",c_int),
    ]
\end{verbatim}
Как видите, ctypes делает очень легким создание C-совместимой структуры. Замечу, что это не полный рецепт пива, и я не советую вам пить смесь ячменя и воды.

Объединения, это почти тоже самое, что и структуры. Однако в объединении все участвующие переменные находятся по одному адресу в памяти. Следующий пример демонстрирует объединение, которое позволяет вам отобразить число тремя разными способами.

Код на C:\\
Код:
\begin{verbatim}
union {
    long barley_long;
    int barley_int;
     char barley_char[8];
}barley_amount;
\end{verbatim}
Код на Python:\\
Код:
\begin{verbatim}
class barley_amount(Union):
    _fields_=[
    ("barley_long", c_long),
    ("barley_int", c_int),
    ("barley_char", c_char * 8),
    ]
\end{verbatim}
%% Если вы присвоите переменной barley_int из объединения barley_amount значение 66, то затем вы сможете использовать переменную barley_char для отображения символа представляющего это число. Для демонстрации создадим новый файл chapter1-unions.py и вобъем следующий код.
%% Код:
%% \begin{verbatim}
%% # chapter1-unions.py
%% from ctypes import *

%% class barley_amount(Union):
%%     _fields_=[
%%     ("barley_long", c_long),
%%     ("barley_int", c_int),
%%     ("barley_char", c_char * 8),
%%     ]
%% value = raw_input("Enter the amount of barley to put into the beer vat:")
%% my_barley = barley_amount(int(value))
%% print "Barley amount as a long: %ld" %my_barley.barley_long
%% print "Barley amount as an int: %d" %my_barley.barley_long
%% print "Barley amount as a char: %s" %my_barley.barley_char
%% \end{verbatim}
%% Вывод будет следующим:\\
%% Код:
%% \begin{verbatim}
%% C:\Python25> python chapter1-unions.py
%% Enter the amount of barley to put into the beer vat:66
%% Barley amount as a long: 66
%% Barley amount as an int: 66
%% Barley amount as a char: B

%% C:\Python25>
%% \end{verbatim}
%% Как видите, присвоив объединению одно значение, вы можете получить три разных представления этого значения. Если вас смущает вывод значения переменной barley_char, а именно буква 'B', то это лишь эквивалент ASCII (американский стандарт кодировки) десятичного 66.

%% Переменная barley_char из этого объединения - отличный пример того, как определять массив в ctypes. В ctypes массив определяется путем умножения типа на количество элементов, которые вы хотите выделить в массиве. В предыдущем примере, 8-элементный массив символов был определен для переменной barley_char из объединения.

%% Теперь у вас есть рабочее окружение Python на двух отдельных системах, и теперь вы понимаете как взаимодействовать с низкоуровневыми библиотеками. Настало время для того, чтобы начать применять эти знания для создания широкого списка инструментов для помощи в реверс-инженерии и хакинге программ. Надеваем шлем.

\chapter{Отладчики и устройство отладчика}
\chapter{Создание отладчика под Windows}
\chapter{PyDbg - Windows отладчик на чистом Python}
\chapter{Immunity Debugger}
\chapter{Hooking}
\chapter{DLL и Code Injection}
\chapter{Fuzzing}
\chapter{Sulley}
\chapter{Фаззинг драйверов Windows}
\chapter{IDAPython}
\chapter{PyEmu}

\end{document}
